#!/bin/bash

#
# Constants

RED_TEXT='\e[0;31m'
NO_COLOR_TEXT='\e[0m'
AMALGAMATE_ERROR='amalgamate error: '

if [ -t 1 ] && [ $(tput colors) \> 0 ]
then
	AMALGAMATE_ERROR="$RED_TEXT$AMALGAMATE_ERROR$NO_COLOR_TEXT"
fi


OUTPUT_DIRECTORY_SUFFIX='amalgamated'
DEFAULT_INPUT_HEADER_EXTENSIONS='h,hh,hpp,hxx,h++,tpp,txx,tpl,ii,ixx,ipp,inl'
DEFAULT_INPUT_SOURCE_EXTENSIONS='c,cc,cpp,cxx,c++'
DEFAULT_OUTPUT_HEADER_EXTENSION='h'
DEFAULT_OUTPUT_SOURCE_EXTENSION='cpp'

HELP_MESSAGE=\
'Usage:
  amalgamate [options]

Options:
  -I <header-path>      Path where header files can be found [default: current working directory'"'"'s parent]
  -e <ext,ens,ions...>  Input header extensions [default: "'"$DEFAULT_INPUT_HEADER_EXTENSIONS"'"].
  -s <ext,ens,ions...>  Input source extensions [default: "'"$DEFAULT_INPUT_SOURCE_EXTENSIONS"'"].
  -o <output-dir-path>  Output directory [default: "../"].
  -H                    Amalgamate all files to single header file.
  -S                    Amalgamate all files to single source file.
  -n <base-name>        Base name for output files [default: parent directory name].
  -x <hpp,cpp>          Extensions for output header and source files [default: inferred from input files; if cannot, then "'"$DEFAULT_OUTPUT_HEADER_EXTENSION"','"$DEFAULT_OUTPUT_SOURCE_EXTENSION"'"].
  -g                    Group unexpanded headers on top.
  -E <count>            Do not allow more than <count> consecutive empty lines.
  -G <id> | -G'"''"'       Use include guard in header instead of `#pragma once`. Use `<id>` for `#define` directive or generate it from header name if empty string was passed.
  -t                    Trim trailing whitespace.
  -a                    Insert annotations.
  -v                    Verbose mode.
  -h                    Show this message.

'

HEADER_STRING_TEMPLATE='%s// ============================================================================\n%s// == %s ==\n%s// =='
FOOTER_STRING_TEMPLATE='%s// ==\n%s// == %s ==\n%s// ============================================================================'

header_search_path=$(dirname $(pwd))
header_extensions="$DEFAULT_INPUT_HEADER_EXTENSIONS"
source_extensions="$DEFAULT_INPUT_SOURCE_EXTENSIONS"
output_dir_path="$(pwd)/.."
header_only=false
source_only=false
name=$(basename $(pwd))
output_header_extension=''
output_source_extension=''
empty_line_count_limit=''
trim_trailing_whitespace=false
include_guard_id=''

make_include_guard_header_function=do-make-include-guard-pragma-once
make_include_guard_footer_function=do-nothing
file_printf_annotation_function=do-nothing
file_print_header_annotation_function=do-nothing
file_print_footer_annotation_function=do-nothing
indent_shift_function=do-nothing
printf_verbose_function=do-nothing
process_standard_header_function=file-printf
prepend_with_standard_includes_function=do-nothing



#
# Functions

printf-stderr()
{
	printf "$@" >&2
}


printf-error()
{
	printf-stderr "$AMALGAMATE_ERROR"
	printf-stderr "$@"
	printf-stderr '\n\n'
}


do-nothing()
{
	:
}


valid-option-string()
{
	local string=$1

	local first_character="${string:0:1}"
	if [ "$first_character" != '-' ]
	then
		return 1
	fi
}


parse-options()
{
	local argument_index=$1
	local options=$2
	local arguments=("${@:3}")

	local char_index=( 0 )
	local char_count="${#options}"
	while [ $char_index -lt $char_count ]
	do
		local option="${options:$char_index:1}"
		case "$option" in
			I)
				((++char_index))
				if [ $char_index == $char_count ]
				then
					((++argument_index))
					header_search_path="${arguments[$argument_index]}"
				else
					header_search_path="${options:$char_index}"
				fi

				if [ ! -d "$header_search_path" ]
				then
					printf-error 'bad header search path "%s"' "$header_search_path"
					exit 1
				fi

				header_search_path=$(expand-dir-path "$header_search_path")

				((++argument_index))
				return $argument_index
				;;

			e)
				((++char_index))
				if [ $char_index == $char_count ]
				then
					((++argument_index))
					header_extensions="${arguments[$argument_index]}"
				else
					header_extensions="${options:$char_index}"
				fi

				((++argument_index))
				return $argument_index
				;;

			s)
				((++char_index))
				if [ $char_index == $char_count ]
				then
					((++argument_index))
					source_extensions="${arguments[$argument_index]}"
				else
					source_extensions="${options:$char_index}"
				fi

				((++argument_index))
				return $argument_index
				;;

			o)
				((++char_index))
				if [ $char_index == $char_count ]
				then
					((++argument_index))
					output_dir_path="${arguments[$argument_index]}"
				else
					output_dir_path="${options:$char_index}"
				fi

				((++argument_index))
				return $argument_index
				;;

			H)
				header_only=true
				((++char_index))
				;;

			S)
				source_only=true
				((++char_index))
				;;

			n)
				((++char_index))
				if [ $char_index == $char_count ]
				then
					((++argument_index))
					name="${arguments[$argument_index]}"
				else
					name="${options:$char_index}"
				fi

				((++argument_index))
				return $argument_index
				;;

			x)
				((++char_index))
				if [ $char_index == $char_count ]
				then
					((++argument_index))
					output_extensions="${arguments[$argument_index]}"
				else
					output_extensions="${options:$char_index}"
				fi

				output_header_extension="${output_extensions%,*}"
				output_source_extension="${output_extensions:${#output_header_extension}+1}"

				if [ -z "$output_header_extension" ]
				then
					printf-error 'output header extension is empty'
					exit 1
				fi

				if [ -z "$output_source_extension" ]
				then
					printf-error 'output source extension is empty'
					exit 1
				fi

				if [ "$output_header_extension" == "$output_source_extension" ]
				then
					printf-error 'extensions for output files cannot be the same'
					exit 1
				fi

				((++argument_index))
				return $argument_index
				;;

			g)
				((++char_index))
				process_standard_header_function=add-standard-include-line
				prepend_with_standard_includes_function=do-prepend-with-standard-includes
				;;

			E)
				((++char_index))
				if [ $char_index == $char_count ]
				then
					((++argument_index))
					empty_line_count_limit="${arguments[$argument_index]}"
				else
					empty_line_count_limit="${options:$char_index}"
				fi

				((++argument_index))
				return $argument_index
				;;

			G)
				((++char_index))
				if [ $char_index == $char_count ]
				then
					((++argument_index))
					include_guard_id="${arguments[$argument_index]}"
				else
					include_guard_id="${options:$char_index}"
				fi

				make_include_guard_header_function=do-make-include-guard-ifdef
				make_include_guard_footer_function=do-make-include-guard-endif

				if [ -n "$inlude_guard_id" ]
				then
					((++argument_index))
				fi

				return $argument_index
				;;

			t)
				((++char_index))
				trim_trailing_whitespace=true
				;;

			a)
				file_printf_annotation_function=file-printf
				file_print_header_annotation_function=do-file-print-header-annotation
				file_print_footer_annotation_function=do-file-print-footer-annotation
				indent_shift_function=do-indent-shift
				((++char_index))
				;;

			v)
				printf_verbose_function=printf
				((++char_index))
				;;

			h)
				printf '%s' "$HELP_MESSAGE"
				((++char_index))
				exit
				;;

			*)
				printf-error 'unknown option "%s"' "$option"
				printf '%s' "$HELP_MESSAGE"
				((++char_index))
				exit 1
				;;
		esac
	done

	((++argument_index))
	return $argument_index
}


setup()
{
	local arguments=("$@")
	local argument_index=( 0 )
	local argument_count=( ${#@} )

	while [ $argument_index -lt $argument_count ]
	do
		local argument="${arguments[$argument_index]}"
		if ! valid-option-string "$argument"
		then
			printf-error 'wrong arguments'
			printf '%s' "$HELP_MESSAGE"
			exit 1
		fi

		local options="${argument:1}"
		parse-options $argument_index "$options" "${arguments[@]}"
		argument_index=$?
	done
}


printf-verbose()
{
	"$printf_verbose_function" "$@"
}


make-include-guard-id()
{
	local file_name=$1

	sed -e 's/-/_/g' -e 's/\./_/g' <<< "$file_name" | tr '[a-z]' '[A-Z]'
}


make-include-guard-header()
{
	"$make_include_guard_header_function" "$@"
}


make-include-guard-footer()
{
	"$make_include_guard_footer_function" "$@"
}


do-make-include-guard-pragma-once()
{
	printf '#pragma once'
}


do-make-include-guard-ifdef()
{
	local id=$1

	printf '#ifndef %s\n#define %s' "$id" "$id"
}


do-make-include-guard-endif()
{
	local id=$1

	printf '#endif // %s' "$id"
}


process-standard-header()
{
	"$process_standard_header_function" "$@"
}


add-standard-include-line()
{
	local include_line=$4
	printf '%s' $(trim-string "$include_line")
}


prepend-with-standard-includes()
{
	"$prepend_with_standard_includes_function" "$@"
}


do-prepend-with-standard-includes()
{
	local output_header_path=$1
	local standard_include_list=("${@:2}")

	file-printf-prepend "$output_header_path" '%s\n\n' "$(IFS=$'\n' sort <<< "${standard_include_list[*]}")"
}


file-printf-annotation()
{
	local output_path=$1
	local format=$2
	local arguments=("${@:3}")

	"$file_printf_annotation_function" "$output_path" "$format" "${arguments[@]}"
}


file-print-header-annotation()
{
	local output_path=$1
	local file_path=$2
	local indent=$3

	"$file_print_header_annotation_function" "$output_path" "$file_path" "$indent"
}


do-file-print-header-annotation()
{
	local output_path=$1
	local file_path=$2
	local indent=$3

	local header_string=$(make-header-string "$file_path" "$indent")
	file-printf "$output_path" '%s\n' "$header_string"
}


file-print-footer-annotation()
{
	local output_path=$1
	local file_path=$2
	local indent=$3

	"$file_print_footer_annotation_function" "$output_path" "$file_path" "$indent"
}


do-file-print-footer-annotation()
{
	local output_path=$1
	local file_path=$2
	local indent=$3

	local footer_string=$(make-footer-string "$file_path" "$indent")
	file-printf "$output_path" '%s\n\n' "$footer_string"
}


indent-shift()
{
	local indent=$1

	"$indent_shift_function" "$indent"
}


do-indent-shift()
{
	local indent=$1

	printf '%s	' "$indent"
}


array-contains-item()
{
	local item=$1
	local array=("${@:2}")

	local current
	for current in ${array[@]}
	do
		if [ "$current" == "$item" ]
		then
			return 0
		fi
	done

	return 1
}


find-by-extensions()
{
	local path=$1
	local extensions=$2

	local arguments=$(sed -e "s/^\([^,]*\)/ -name '*.\1'/g" -e "s/,\([^,]*\)/ -or -name '*.\1'/g" <<< "$extensions")
	eval 'find '"$path"' -type f '"$arguments"
}


is-include-line()
{
	local line=$1

	[[ $line =~ ^[\ \	]*\#[\ \t]*include[\ \t]*\".*\".* ]]
}


is-standard-include-line()
{
	local line=$1

	[[ $line =~ ^[\ \	]*\#[\ \t]*include[\ \t]*\<.*\>.* ]]
}


is-pragma-once-line()
{
	local line=$1

	[[ $line =~ ^[\ \	]*\#[\ \t]*pragma[\ \t]*once.* ]]
}


is-empty-line()
{
	local line=$1

	[[ $line =~ ^[\ \	]*$ ]]
}


path-extension()
{
	local path=$1

	printf '%s\n' "${path##*.}"
}


detect-extension()
{
	local default_extension=$1
	local first_path=$2
	shift
	shift
	local paths=("$@")

	local first_extension=$(path-extension "$first_path")

	local path
	for path in "${paths[@]}"
	do
		local extension=$(path-extension "$path")
		if [ "$first_extension" != "$extension" ]
		then
			printf '%s\n' "$default_extension"
			return 0
		fi
	done

	printf '%s\n' "$first_extension"
	return 0
}


expand-dir-path()
{
	local path=$1

	local absolute_dir_path=$(cd $path; pwd)

	printf '%s\n' "$absolute_dir_path"
}


expand-path()
{
	local path=$1

	local dir=$(dirname "$path")
	local base_name=$(basename "$path")
	local absolute_dir_path=$(expand-dir-path "$dir")

	printf '%s\n' "$absolute_dir_path/$base_name"
}


relative-path()
{
	local path=$1
	local base_path=$2

	local relative_path="${path#$base_path}"
	if [ "$relative_path" != "$path" ]
	then
		relative_path=".$relative_path"
	fi

	printf '%s\n' "$relative_path"
}


path-from-include-line()
{
	local line=$1

	local file_path=${line#*\"}
	local file_path=${file_path%\"*}

	printf '%s\n' "$file_path"
}


path-from-standard-include-line()
{
	local line=$1

	local file_path=${line#*\<}
	local file_path=${file_path%\>*}

	printf '%s\n' "$file_path"
}


absolute-path-from-include-line()
{
	local line=$1

	local file_path=${line#*\"}
	local file_path=${file_path%\"*}

	expand-path "$file_path"
}


file-printf()
{
	local file_path=$1
	local format=$2
	local arguments=("${@:3}")

	printf "$format" "${arguments[@]}" >> "$file_path"
}


file-printf-prepend()
{
	local file_path=$1
	local format=$2
	local arguments=("${@:3}")

	printf '%s' "$(printf "$format" "${arguments[@]}"; printf '%s' $(cat "$file_path"))" > "$file_path"
}


make-header-string()
{
	local line=$1
	local indent=$2

	printf "$HEADER_STRING_TEMPLATE" "$indent" "$indent" "$line" "$indent"
}


make-footer-string()
{
	local line=$1
	local indent=$2

	printf "$FOOTER_STRING_TEMPLATE" "$indent" "$indent" "$line" "$indent"
}


resolve-include-path()
{
	local include_path=$1
	local absolute_file_path=$2

	local dir=$(dirname "$absolute_file_path")
	local non_expanded_path="$dir/$include_path"

	if [ -f "$non_expanded_path" ]
	then
		expand-path "$non_expanded_path"
		return
	fi

	local absolute_include_path="$header_search_path/$include_path"
	if [ ! -f "$absolute_include_path" ]
	then
		return 1
	fi

	printf '%s\n' "$absolute_include_path"
}


get-meta-tag()
{
	local line=$1

	if ! [[ "$line" =~ ^.*\/\/[\ \	]*\[[\ \	]*amalgamate:[\ \	]*[-a-z][-a-z]*[\ \	]*\][\ \	]*$ ]]
	then
		return
	fi

	sed -e 's/^.*\/\/[\ \	]*\[[\ \	]*amalgamate:[\ \	]*//' -e 's/[\ \	]*\].*$//' <<< "$line"
}


get-clean-line()
{
	local line=$1

	sed -e 's/[\ \t]*\/\/[\ \t]*\[amalgamate:[\ \t]*[-a-z][-a-z]*[\ \t]*\][\ \t]*$//' <<< "$line"
}


declare -a included_files
declare -a globally_included_standard_files
declare -a locally_included_standard_files

expand-file()
{
	IFS=''
	local absolute_file_path=$1
	local output_path=$2
	local indent=$3

	local relative_file_path=$(relative-path "$absolute_file_path" $(pwd))
	printf-verbose '%s\n' "$relative_file_path"

	file-print-header-annotation "$output_path" "$relative_file_path" "$indent"

	local line
	while read -r line || [ -n "$line" ]
	do
		local meta_tag=$(get-meta-tag "$line")
		if [ "$meta_tag" == 'leave' ]
		then
			local clean_line=$(get-clean-line "$line")
			file-printf "$output_path" '%s%s\n' "$indent" "$clean_line"
			continue
		elif [ "$meta_tag" == 'remove' ]
		then
			continue
		elif [ "$meta_tag" == 'uncomment' ]
		then
			local clean_line=$(get-clean-line "$line")
			line="${clean_line#*//}"
		fi

		if is-include-line "$line"
		then
			local include_path=$(path-from-include-line "$line")
			local absolute_include_path=$(resolve-include-path "$include_path" "$absolute_file_path")
			if [ -z "$absolute_include_path" ]
			then
				printf-error 'cannot find include file "%s" required in "%s"' "$include_path" "$absolute_file_path"
				exit 1
			fi

			if array-contains-item "$absolute_include_path" "${included_files[@]}"
			then
				file-printf-annotation "$output_path" '%s// %s    // amalgamate: file already expanded\n' "$indent" "$line"
				continue
			fi

			included_files+=("$absolute_include_path")
			expand-file "$absolute_include_path" "$output_path" "$(indent-shift "$indent")"

			continue
		fi

		if is-pragma-once-line "$line"
		then
			file-printf-annotation "$output_path" '%s// %s' "$indent" "$line"
			continue
		fi

		if is-empty-line "$line"
		then
			file-printf "$output_path" "%s\n" "$line"
			continue
		fi

		if is-standard-include-line "$line"
		then
			local standard_include_path=$(path-from-standard-include-line "$line")
			if array-contains-item "$standard_include_path" "${globally_included_standard_files[@]}"
			then
				file-printf-annotation "$output_path" '%s// %s    // amalgamate: file already included\n' "$indent" "$line"
				continue
			fi

			globally_included_standard_files+=("$standard_include_path")
			locally_included_standard_files+=($(process-standard-header "$output_path" '%s%s\n' "$indent" "$line"))
			continue
		fi

		file-printf "$output_path" '%s%s\n' "$indent" "$line"
	done < "$absolute_file_path"

	file-print-footer-annotation "$output_path" "$relative_file_path" "$indent"
}


merge-headers()
{
	local output_header_path=$1
	shift
	local paths=("$@")

	locally_included_standard_files=()

	local path
	for path in "${paths[@]}"
	do
		local file_absolute_path=$(expand-path "$path")

		if array-contains-item "$file_absolute_path" "${included_files[@]}"
		then
			continue
		fi

		included_files+=("$file_absolute_path")
		expand-file "$file_absolute_path" "$output_header_path" ''
	done

	prepend-with-standard-includes "$output_header_path" "${locally_included_standard_files[@]}"
}


merge-sources()
{
	local output_source_path=$1
	shift
	local paths=("$@")

	locally_included_standard_files=()

	local path
	for path in "${paths[@]}"
	do
		local file_absolute_path=$(expand-path "$path")

		expand-file "$file_absolute_path" "$output_source_path" ''
	done

	prepend-with-standard-includes "$output_source_path" "${locally_included_standard_files[@]}"
}


reduce-empty-lines()
{
	local file_path=$1
	local empty_line_limit=$2

	local temp="$file_path.tmp"
	mktemp "$temp" &> /dev/null

	local empty_line_count=0
	local line
	while read -r line || [ -n "$line" ]
	do
		if [ -z "$line" ]
		then
			((++empty_line_count))
			if (( empty_line_count > empty_line_limit ))
			then
				continue
			fi
		else
			empty_line_count=0
		fi

		printf '%s\n' "$line" >> "$temp"
	done < "$file_path"

	mv -f "$temp" "$file_path"
}


trim-string()
{
	local string=$1

	sed -e 's/^[	 ][	 ]*//g' -e 's/[	 ][	 ]*$//g' <<< "$string"
}


trim-trailing-whitespace()
{
	local file_path=$1

	sed -i .bak 's/[	 ][	 ]*$//g' "$file_path"
	if [ $? != 0 ]
	then
		exit 1
	fi

	rm "$file_path.bak"
}


#
# Main

setup "$@"


output_dir_path="$output_dir_path/$name-$OUTPUT_DIRECTORY_SUFFIX"
rm -rf "$output_dir_path" &> /dev/null
if [ $? != 0 ]
then
	printf-error 'cannot remove output directory "%s"' "$output_dir_path"
	exit 1
fi

mkdir -p "$output_dir_path"
if [ $? != 0 ]
then
	printf-error 'cannot write path "%s"' "$output_dir_path"
	exit 1
fi

output_dir_path=$(expand-dir-path "$output_dir_path")


IFS=$'\n'
header_files=($(find-by-extensions . "$header_extensions"))
source_files=($(find-by-extensions . "$source_extensions"))

if [ "${#header_files[@]}" == 0 ] && [ "${#source_files[@]}" == 0 ]
then
	printf-error 'no C/C++ files found'
	exit 1
fi


if [ -z "$output_header_extension" ]
then
	output_header_extension=$(detect-extension "$DEFAULT_OUTPUT_HEADER_EXTENSION" "${header_files[@]}")
fi

if [ -z "$output_source_extension" ]
then
	output_source_extension=$(detect-extension "$DEFAULT_OUTPUT_SOURCE_EXTENSION" "${source_files[@]}")
fi

header_file_name="$name.$output_header_extension"
source_file_name="$name.$output_source_extension"

output_header_path="$output_dir_path/$header_file_name"
output_source_path="$output_dir_path/$source_file_name"


# Printing options

printf-verbose 'Header search path: %s\n' "$header_search_path"
printf-verbose 'Input header extensions: %s\n' "$header_extensions"
printf-verbose 'Input source extensions: %s\n' "$source_extensions"
printf-verbose 'Base name: %s\n' "$name"
if $header_only
then
	printf-verbose 'Header only\n'
	printf-verbose 'Output header extension: %s\n' "$output_header_extension"
elif $source_only
then
	printf-verbose 'Source only'
	printf-verbose 'Output source extension: %s\n' "$output_source_extension"
else
	printf-verbose 'Output header extension: %s\n' "$output_header_extension"
	printf-verbose 'Output source extension: %s\n' "$output_source_extension"
fi

printf-verbose 'Reduce consecutive empty lines to: %s\n' "$empty_line_count_limit"

if $trim_trailing_whitespace
then
	printf-verbose 'Trim trailing whitespace: yes\n'
else
	printf-verbose 'Trim trailing whitespace: no\n'
fi

if [ "$file_printf_annotation_function" != 'do-nothing' ]
then
	printf-verbose 'Insert annotations: yes\n'
else
	printf-verbose 'Insert annotations: no\n'
fi

printf-verbose '\nSaving amalgamated files to:\n%s/\n' "$output_dir_path"
if $header_only
then
	output_source_path="$output_header_path"
	printf-verbose '└── %s\n\n' "$header_file_name"
elif $source_only
then
	output_header_path="$output_source_path"
	printf-verbose '└── %s\n\n' "$source_file_name"
else
	printf-verbose '├── %s\n└── %s\n\n' "$header_file_name" "$source_file_name"
fi


rm -f "$output_header_path" "$output_source_path"

included_files+=("$output_header_path")

printf-verbose 'Amalgamating headers...\n'

merge-headers "$output_header_path" "${header_files[@]}"

if ! $source_only
then
	include_guard_id=$(make-include-guard-id "$header_file_name")

	include_guard_header=$(make-include-guard-header "$include_guard_id")
	file-printf-prepend "$output_header_path" '%s\n\n' "${include_guard_header}"

	include_guard_footer=$(make-include-guard-footer "$include_guard_id")
	file-printf "$output_header_path" '\n\n%s' "$include_guard_footer"
fi

printf-verbose '\nAmalgamating sources...\n'
if ! $source_only
then
	file-printf "$output_source_path" '#include "%s"\n' "$(basename $header_file_name)"
fi

merge-sources "$output_source_path" "${source_files[@]}"

if $trim_trailing_whitespace
then
	printf-verbose 'Trimming trailing whitespace...\n'
	trim-trailing-whitespace "$output_header_path"
	trim-trailing-whitespace "$output_source_path"
fi

if [ -n "$empty_line_count_limit" ]
then
	printf-verbose '\nReducing empty lines...\n'
	reduce-empty-lines "$output_header_path" $empty_line_count_limit
	reduce-empty-lines "$output_source_path" $empty_line_count_limit
fi

printf-verbose '\nDone.\n\n'

