#!/bin/bash

#
# Constants

HELP_MESSAGE='Usage:
  ./amalgamate [options]

  -n, --name <base_name>     specify base name of the output files
  -o, --output <dir_path>    specify output directory
  -a, --annotate             insert annotations
  -v, --verbose              verbose mode
  -h, --help                 show this message

'

HEADER_STRING_TEMPLATE='%s// ============================================================================\n%s// == %s ==%s'
FOOTER_STRING_TEMPLATE='\n%s// == %s ==\n%s// ============================================================================%s'

DEFAULT_OUTPUT_FOLDER='amalgamated'

name=$(basename $(pwd))
output_dir_path="$(pwd)/$DEFAULT_OUTPUT_FOLDER/"
file_printf_annotation_function=do_nothing
file_print_header_annotation_function=do_nothing
file_print_footer_annotation_function=do_nothing
printf_verbose_function=do_nothing


#
# Functions

do_nothing()
{
	:
}


setup()
{
	local arguments=("$@")

	local index=( 0 )
	local argument_count="${#arguments[@]}"
	while [ $index -lt $argument_count ]
	do
		local argument="${arguments[$index]}"
		case "$argument" in
			-n|--name)
				((++index))
				name="${arguments[$index]}"
				;;

			-o|--output)
				((++index))
				output_dir_path=$(expand_path "${arguments[$index]}")/
				;;

			-a|--annotate)
				file_printf_annotation_function=file_printf
				file_print_header_annotation_function=do_file_print_header_annotation
				file_print_footer_annotation_function=do_file_print_footer_annotation
				;;

			-v|--verbose)
				printf_verbose_function=printf
				;;

			-h|--help)
				printf "$HELP_MESSAGE"
				exit
				;;
		esac

		((++index))
	done
}


printf_verbose()
{
	local format=$1

	"$printf_verbose_function" "$format" "${@:2}"
}


file_printf_annotation()
{
	local output_path=$1
	local format=$2

	"$file_printf_annotation_function" "$output_path" "$format" "${@:3}"
}


file_print_header_annotation()
{
	local output_path=$1
	local file_path=$2
	local indent=$3

	"$file_print_header_annotation_function" "$output_path" "$file_path" "$indent"
}


do_file_print_header_annotation()
{
	local output_path=$1
	local file_path=$2
	local indent=$3

	local header_string=$(make_header_string "$file_path" "$indent")
	file_printf "$output_path" "$header_string"
}


file_print_footer_annotation()
{
	local output_path=$1
	local file_path=$2
	local indent=$3

	"$file_print_footer_annotation_function" "$output_path" "$file_path" "$indent"
}


do_file_print_footer_annotation()
{
	local output_path=$1
	local file_path=$2
	local indent=$3

	local footer_string=$(make_footer_string "$file_path" "$indent")
	file_printf "$output_path" "$footer_string"
}


printf_error()
{
	local format=$1

	printf "Error: $format" "${@:2}" >&2
}


assert_dir_exists()
{
	local dir=$1
	local format=$2

	if [ -a "$dir" ]
	then
		printf_error "$format" "${@:3}"
		exit 1
	fi
}


assert_path_readable()
{
	local path=$1

	if [ ! -r "$path" ]
	then
		printf_error 'file %s does not exist or not readble.\n' "$path"
		exit 1
	fi
}


array_contains_item()
{
	local item=$1
	local array=("${@:2}")

	local current
	for current in ${array[@]}
	do
		if [ "$current" == "$item" ]
		then
			return 0
		fi
	done

	return 1
}


is_include_line()
{
	local line=$1

	[[ $line =~ ^[\ \t]*\#[\ \t]*include[\ \t]*\".*\"[\ \t]*$ ]]
}


is_pragma_once_line()
{
	local line=$1

	[[ $line =~ ^[\ \t]*\#[\ \t]*pragma[\ \t]*once[\ \t]*$ ]]
}


is_empty_line()
{
	local line=$1

	[[ $line =~ ^[\ \t]*$ ]]
}


expand_dir_path()
{
	local path=$1

	local absolute_dir_path="$(cd $(pwd)/$path; pwd)"

	printf '%s\n' "$absolute_dir_path"
}


expand_path()
{
	local path=$1

	local dir=$(dirname $path)
	local base_name=$(basename $path)
	local absolute_dir_path=$(expand_dir_path "$dir")

	printf '%s\n' "$absolute_dir_path/$base_name"
}


path_from_include_line()
{
	local line=$1

	local file_path=${line#*\"}
	local file_path=${file_path%\"*}

	printf '%s\n' "$file_path"
}


absolute_path_from_include_line()
{
	local line=$1

	local file_path=${line#*\"}
	local file_path=${file_path%\"*}

	expand_path "$file_path"
}


file_printf()
{
	local file_path=$1
	local format=$2
	local arguments=$3

	printf "$format" "${@:3}" >> "$file_path"
}


make_header_string()
{
	local line=$1
	local indent=$2

	printf "$HEADER_STRING_TEMPLATE\n" "$indent" "$indent" "$line" '\n\n'
}


make_footer_string()
{
	local line=$1
	local indent=$2

	printf "$FOOTER_STRING_TEMPLATE\n" "$indent" "$line" "$indent" '\n\n'
}


declare -a included_files

IFS=''
expand_file()
{
	local file_relative_path=$1
	local file_path=$2
	local output_path=$3
	local indent=$4

	printf_verbose '%s\n' "$file_relative_path"
	assert_path_readable "$file_relative_path"

	file_print_header_annotation "$output_path" "$file_relative_path" "$indent"

	local file_dir=$(dirname "$file_path")
	cd "$file_dir"

	local file_name=$(basename "$file_path")

	local line
	while read -r line
	do
		if is_include_line "$line"
		then
			local include_path=$(path_from_include_line "$line")
			local absolute_include_path=$(expand_path "$include_path")

			if array_contains_item "$absolute_include_path" "${included_files[@]}"
			then
				file_printf_annotation "$output_path" '%s// %s    // amalgamate: file already expanded\n' "$indent" "$line"
				continue
			fi

			included_files+=("$absolute_include_path")
			local current_dir=$(pwd)
			expand_file "$include_path" "$absolute_include_path" "$output_path" "$indent	"
			cd "$current_dir"

			continue
		fi

		if is_pragma_once_line "$line"
		then
			file_printf_annotation "$output_path" '%s// %s' "$indent" "$line"

			continue
		fi

		if ! is_empty_line "$line"
		then
			file_printf "$output_path" '%s' "$indent"
		fi

		file_printf "$output_path" '%s\n' "$line"
	done < "$file_name"

	file_print_footer_annotation "$output_path" "$file_relative_path" "$indent"
}


merge_headers()
{
	local path=$1
	local output_header_path=$2

	local relative_output_dir_path="${output_dir_path#$(pwd)}"
	local source_files=$(find "$path" -not -path ".$relative_output_dir_path*" -name '*.h')
	local file_path
	while read -r file_path
	do
		local absolute_file_path=$(expand_path "$file_path")

		if array_contains_item "$absolute_file_path" "${included_files[@]}"
		then
			file_printf "$output_header_path" '%s// %s    // amalgamate: file already expanded\n' "$indent" "$line"
			continue
		fi

		included_files+=("$absolute_file_path")
		local current_dir=$(pwd)
		expand_file "$file_path" "$absolute_file_path" "$output_header_path"
		cd "$current_dir"
	done <<< "$source_files"
}


merge_sources()
{
	local path=$1
	local output_source_path=$2

	local relative_output_dir_path="${output_dir_path#$(pwd)}"
	local source_files=$(find "$path" -not -path ".$relative_output_dir_path*" -name '*.cpp')
	local file_path
	while read -r file_path
	do
		local absolute_file_path=$(expand_path "$file_path")

		local current_dir=$(pwd)
		expand_file "$file_path" "$absolute_file_path" "$output_source_path"
		cd "$current_dir"
	done <<< "$source_files"
}


#
# Main

setup "$@"

assert_dir_exists "$output_dir_path" 'output directory already exists\n'
mkdir "$output_dir_path"

printf_verbose 'Name: %s\nOutput dir: %s\n\n' "$name" "$output_dir_path"

header_file_name="$name.h"
source_file_name="$name.cpp"

output_header_path="$output_dir_path$header_file_name"
output_source_path="$output_dir_path$source_file_name"

included_files+=("$output_header_path")


printf_verbose 'Merging headers...\n'
file_printf "$output_header_path" '#pragma once\n'
merge_headers . "$output_header_path"

printf_verbose '\nMerging sources...\n'
file_printf "$output_source_path" '#include "%s"\n' "$(basename $header_file_name)"
merge_sources . "$output_source_path"

printf_verbose '\nDone.\n\n'

